## 비동기 코드 매커니즘

비동기 코드를 다룰 때는 **기다리는 작업이 개발자의 명확한 의도하에 하는 작업**이 된다.

비동기 코드를 구현하는 매커니즘 두가지를 알아보자.

### 콜백 매커니즘

비동기 작업이 완료될 때 콜백 함수를 호출하는 방식.

**콜백 함수가 종료점이 된다.**

### Async/await 매커니즘

진입점이 종료점이 된다.

비동기 코드를 **동기 코드처럼 동작시키고, 값, 오류를 반환**한다.

## 비동기 코드를 직접 테스트하는 방법

### 콜백 매커니즘

jest에서는 `done()` 이라는 콜백 함수를 사용해서 명시적으로 기다리게 할 수 있다.

```tsx
test("테스트", (done) => {
	...비동기 코드...
	expect()...
	done();
});
```

### Async/await 매커니즘

async/await 매커니즘에선 테스트가 동기 코드마냥 간단해진다.

```tsx
test("테스트", async () => {
	await 비동기 코드
	expect()...
});
```

### 한계..

비동기 코드를 직접 테스트하는 방식은 통합 테스트라고 볼 수 있다. ( 단위 테스트 아니라서 )

따라서 단위 테스트에 비해 속도도 느리며 결과가 항상 동일하다고 볼 수도 없다.

그렇다면, 비동기 작업과 관련된 모든 테스트를 통합 테스트로 처리할 수 밖에 없는걸까? 그건 아님!

## 비동기 코드를 단위테스트로 테스트하는 방법

두가지 방법이 있다. ( ***진입점 분리 패턴*** / ***어댑터 분리 패턴*** )

### 진입점 분리 패턴

비동기 작업을 두 부분으로 나누면 다음과 같이 나눌 수 있다.

1. 비동기 작업.
2. 비동기 작업 결과를 처리하는 로직.

**진입점 분리 패턴**은 비동기 작업 결과를 처리하는 로직을 별도의 함수로 분리하는 패턴이다.

이 분리된 함수를 외부에 노출시켜 단위 테스트의 진입점으로 사용할 수 있게 한다.

### 어댑터 분리 패턴

진입점 분리 패턴과는 반대의 접근법. 비동기 작업을 의존성처럼 여긴다. 

앞선 장에서 의존성을 다루는 전략을 세가지 알아냈다. 그 전략을 사용하면 된다.

1. 모듈형 - 의존성 모듈을 모의 객체로 만들어 이 객체에 의존하게 만드는 방법
2. 함수형 - 매개변수 하나 더 뚫고 의존성 주입 ( 가짜 주입 )
3. 객체 지향형 - 인터페이스에 의존하고, 인터페이스를 구현한 모의 객체를 만들어 주입

## 타이머 다루는 방법

비동기적인 타이머를 동기적으로 동작시켜 테스트하는 방법이 있다.

1. 몽키 패칭 (런타임에 코드나 객체 동작을 변경)
    - 전역 객체에 담겨있던 본래의 타이머 함수를 동기적 코드로 바꿔놨다가 원래의 함수로 복원
2. jest로 비동기 타이머를 동기적으로 대체하는 방법
    - jest.useFakeTimers : 다양한 타이머 함수(setTimer, setInterval…)를 스텁으로 대체
    - jest.clearAllTimers : 실행이 예약된 모든 타이머를 취소
    - jest.resetAllTimers : 스텁으로 대체된 타이머를 다시 원래대로 돌려놓는다.
        - 특정 테스트에만 한정에서 타이머를 대체하고 싶다면, 특정 테스트 끝나고 원.복 필요!
    - jest.advanceTimersToNextTimer : 다음 실행될 타이머를 실행시킨다.

## 이벤트 처리

### 이벤트 이미터(**EventEmitter)**

**`EventEmitter`** 객체를 상속

**`emit()`** 메소드로 이벤트를 발생시키고 **`on()`** 메소드로 리스너 등록시킬 수 있다.

### UI 이벤트 처리 ( Html 문서에 변경된 내용은.. )

중요한 것은 이벤트가 발생했는지에 대한 여부가 아니라, 이벤트로 인해 Html 문서가 어떻게 변화했는가.

Html 문서를 추적해서 테스트를 도와주는 라이브러리가 있다 ( 대표적으로 DOM Testing Library )

- getByText : 인자로 넘겨준 텍스트를 갖고 있는 엘리먼트를 찾아서 가져온다.
- fireEvent : 이벤트를 직접적으로 발생시킨다.
- findByText : 인자로 넘겨준 텍스트를 갖고 있는 엘리먼트가 있는지 없는지 여부를 판단.
