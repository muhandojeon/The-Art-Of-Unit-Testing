# 단위테스트의 기술 3장. 의존성 분리와 스텁

날짜: 2025년 2월 25일 오후 10:00 (GMT+9) → 오후 11:00
분류: STUDY_LOG

작업 단위 종료점 유형은 세가지임.

1. 반환값을 가진 종료점
2. 상태값을 변경하는 종료점
3. 서드파티(외부 요소) 호출하는 종료점

서드 파티(외부 요소)를 호출하는 것은 단위 테스트라고 하기 어렵다 했음.

이걸 단위 테스트로써 처리하려면 두가지 방법이 있음.

1. 코드 리팩토링
2. 몽키 패칭 - 런타임에 코드나 객체 동작을 변경하는 기술

---

코드에서 의존하는 서드 파티(외부 요소)를 의존성이라 함.

의존성에는 두가지 유형이 있음.

1. 외부로 나가는 의존성
2. 내부로 들어오는 의존성

외부로 나가는 의존성은 작업이나 명령을 실행한 후 결과를 기다리지 않고 바로 다음 작업을 수행하는 방식임. ( 간접 출력 )

내부로 들어오는 의존성은 테스트에 필요한 데이터나 동작을 작업 단위에 제공하는 방식임. ( 간접 입력 )

※ ‘간접’ 이라는건 ‘외부’ 라고 이해해도 될까.

어떤 의존성은 외부로 나가는 의존성이면서 동시에 내부로 들어오는 의존성이기도 함.

---

의존성을 단위 테스트에서 처리하려면  실제 의존성을 대체하거나 모방할 필요성이 있음. ( 위에서 잠깐 언급한 **몽키 패칭** )

대체하고 모방하는 패턴의 카테고리는 다음과 같다.

1. 스텁
2. 목
3. 테스트 더블(페이크)

스텁은 내부로 들어오는 의존성을 끊어(모방)하는데, 테스트 대상(SUT)에 미리 정의된 가짜 데이터를 제공하는 방식이다.

목은 외부로 나가는 의존성을 끊어(모방)하는 방식이다. 외부에 실제 영향을 미치지 않고, 영향을 끼치는 것을 모방한 것을 예상대로 잘 호출했는지 검증한다. 

페이크는 실제 구현을 대체하는 모든 것들을 지칭하며, 스텁과 목을 모두 아우르는 표현이다.

---

좋은 테스트는 ‘일관성’을 보장해야한다.

이 말은 테스트를 언제 실행해도 이전 실행과 같은 결과를 보장해야한다는 것이다.

따라서, ‘일관성’을 보장하기 위해서 테스트를 구성하는 여러 변수, 환경 등 온전히 통제할 수 있어야 한다.

외부와 직접적으로 연결된 의존성은 우리가 통제가 불가능하다..

외부와의 연관 관계를 끊고, 가짜 의존성(스텁)으로 대체하면 통제권을 우리가 갖고올 수 있다. → ‘일관성’ 보장 가능!

아래에서 설명할 것들은 작업 단위에 스텁을 주입하는 방법들이며, 의존성 주입의 다양한 형태라고 볼 수 있다.

※ 의존성의 동작 방식을 내부에서 생성하지 않고 외부(함수 호출자 - 테스트 코드)에서 주입받도록 코드 설계를 변경하는 것을 **제어의 역전**이라고 한다.

※ 의존성을 주입하는 지점을 심(Seam) 이라고 한다.

---

**작업 단위에 스텁을 주입할 수 있는 방법1. 값 혹은 함수를 매개변수로 주입**

매개변수로 단순한 값을 주입할 수도 있지만, 그 값을 반환하는 함수를 매개변수로 주입하는 방식을 사용할 수 있다.

모든 의존성을 외부로부터 주입받아 사용하는 순수함수는 일반적으로 테스트하기 훨씬 쉽다.

---

**작업 단위에 스텁을 주입할 수 있는 방법2. 부분 적용(커링) 및 팩토리 함수**

일부 컨텍스트 ( ex. 스텁으로 대체한 의존성）가 미리 설정된 상태로 반환하는 함수를 생성

함수를 반환한다 → 반환된 이 함수는 이미 스텁이 심겨진 상태의 함수라서 우리 통제 내에 있는 함수이다.

 

---

**작업 단위에 스텁을 주입할 수 있는 방법3. 모듈 주입**

직접적으로 외부 의존성을 끊어내고, 중간 단계를 거쳐서 의존성을 연결.

이 중간 단계를 통해 외부 의존성을 우리가 만든 가짜 모듈로 대체할 수 있다.

테스트가 끝나면 작업 단위 내에 있는 모듈 의존성을 원래 상태로 되돌려야한다.

이 중간 단계를 의존성을 주입하는 지점(심 - Seam)이라고 볼 수 있다.

근데, 이 방식은 테스트를 우리가 가짜로 만든 의존성의 API에 매우 강하게 묶이게 한다.

이게 왜 단점이냐면, 예를 들어 moment를 가짜 객체로 갈아끼워서 moment().day()를 테스트에 맞게 대체해서 사용하고 있었다 쳐보자.

만약 외부 의존성의 명세가 .day() 에서 .getDay() 라고 바뀌었다고 한다면, 가짜로 만들었던 .day()를 다 .getDay()로 바꿔줘야 한다. → 이게 많아진다면 골치아파..

그래서 이 방식은 필자가 비추하긴 한다. 다른 방식을 추천..!

---

**작업 단위에 스텁을 주입할 수 있는 방법3-1. 포트와 어댑터 아키텍쳐 (헥사고날 아키텍쳐)**

※ *‘포트’와 ‘어댑터’ 아키텍쳐 아님! → ‘포트와 어댑터’ 아키텍쳐임! → 헥사고날 아키텍쳐라고도 함.*

모듈 주입하는 방식은 제어할 수 없는 외부 의존성의 명세를 코드에 직접 가져와서 생기는 단점이 있었음 → ‘우리가 항상 제어할 수 있는 중간 추상화 단계를 두는게 어떨까?’ 에서 개념 출발.

**포트** : 시스템 내부와 외부를 연결하는 추상화 정의를 의미 (interface 혹은 abstract class)

**어댑터** : 포트를 구현한 구체적인 구현체 (concrete port) : 내부와 외부를 중간에서 연결하여 서로 안맞는 명세를 호환시켜주는 역할

이 방식은 모듈 주입 방식과 비교하여 유지보수 / 테스트 용이성 / 유연성의 장점이 있다.

---

**작업 단위에 스텁을 주입할 수 있는 방법4. 객체 지향적으로 의존성 주입하기**

방법3까지는 함수형 프로그래밍으로 접근했는데, 객체 지향적으로 접근하는 방법도 있다.

상황에 가장 적합한 방식을 적용하는 것이 현명.

4-1. 클래스 생성자의 매개변수 통하여 인스턴스 생성할 때 의존성 주입할 수 있다.

- 값을 직접적으로 넣어주거나, 값을 반환하는 함수를 넣어주는 것이 일반적.

4-2. 공통 인터페이스 활용 → 이 인터페이스를 원본 의존성과 스텁이 모두 구현.

- 원본과 동일한 동작을 구현해야하는 fake 객체로 구현하여 테스트함.