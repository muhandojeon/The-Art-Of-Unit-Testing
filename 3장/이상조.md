# 의존성 분리와 스텁

## 의존성 유형

- 외부로 나가는 의존성: 작업 단위의 종료점을 나타내는 의존성. 로거 함수, DB저장, 이메일 발송 ... fire-and-forget 시나리오
- 내부로 들어오는 의존성: 종료점을 나타내지 않는 의존성. 작업 단위의 최종 동작에 대한 요구사항이 아님. 테스트에 필요한 특수한 데이터나 동작을 작업 단위에 제공하는 역할. 작업 단위로 들어오는 수동적인 데이터 조각.
  내부로 들어오는 의존성이라는건 구체적으로 어떻게 들어온다는 걸까? param으로 들어오는 것 이외에 어떤 방법이 있을까? context api? hooks?

스텁은 내부로 들어오는 의존성(간접 입력)을 끊어 준다. 스텁은 검증하지 않는다. 하나의 테스트에서 여러 스텁을 사용할 수 있다.  
그러니까 위의 예와 합치면... 작업 단위 내부로 들어오는 데이터 조각(api콜의 반환값이라던지, 특정한 param같은 것들)이 실제 외부 컨텍스트에서 만들어지는 것이 아니고 임의로 생성해서 주입해주는 것이라는 뜻 같음.  
당연히 내가 임의로 만든 것이므로 검증할 이유도 없음.

목은 외부로 나가는 의존성(간접 출력 또는 종료점)을 끊어 준다. 목은 종료점을 의미하므로 하나의 테스트에 하나만 사용하는 것이 좋다.  
스텁은 그냥 객체고, 목은 함수고 뭐 그런 건줄 알았는데, 그런 형태적인 것으로 정해지는건 아닌 것 같다.  
테스트에 필요한 데이터를 제공하는게 스텁, 테스트가 제대로 됐나~ 확인하기 위해(검증을 하느냐) 사용하는 것이 목. 이렇게 생각하면 좀 명확해지는 것 같다.  
예를 들어, jest.fn()도 때로는 스텁이고, 때로는 목이 될 수 있다. 검증을 하느냐 마느냐로 구분한다면 jest.fn()이 호출됐냐?! 라고 물어본다면(expect) 그건 목, 아니라면 스텁

책에서 말하는 페이크가 무엇인지 조금 모호한데, 저자 설명은 테스트 더블을 다르게 부르는 말이라고 적혀있다. 역자 설명으로는 실제 구현을 대체하는 가벼운 버전의 구성요소를 제공하여 테스트를 수행한다고 적혀있음.  
좀 찾아보니 페이크는 역자 설명에 더 가까운 것 같다.  
그리고 페이크는 목이랑 비교가 많이 되는 것 같음.  
페이크는 다소 결과 중심적인 테스트를 위한 것. 예를 들어, DB를 비슷하게 흉내내서 만든 페이크는 결국 페이크가 어떻게 변경되었나를 봐야하므로 결과 중심.  
목은 특정 메서드가 특정한 조건이나 방식으로 호출되었는지를 검증해야 하기 때문에 내부 동작을 검증하는 것으로 볼 수 있겠음. 물론 그게 구현을 들여다본다는 의미는 아니고...

## 스텁을 사용하는 이유

책에서는 const TODAY = moment().day();로 인해 주말에만 테스트가 실행되는 문제를 이야기함.  
이게 결국 비결정적 테스트를 허용하는가에 대한 문제인데, 찬성의견과 반대의견이 있는 것으로 알고있음.

## 스텁을 사용하는 일반적인 설계 방식

- currentDay를 param으로 받아버리는 것. 가장 간단하다. 제어의 역전. 내가 결정하지 않고 상위 컨텍스트로 넘긴다. 그리고 단순히 실행만 할 뿐인 것.
- 이제 역효과 가능성이 없는 순수 함수로 다시 태어났다고 볼 수 있다. -> 부수 효과가 없어졌다. 부수 효과란 함수가 반환 값 외에 외부 세계와 주고받는 모든 영향을 말하는 것. 이 경우에는 원래 날짜 데이터에 직접 접근
- 그러나 잘 생각해보면 결국 currentDay도 외부에서 받은 데이터인데? 그렇긴 하지만, 제어의 역전으로 인해 함수는 외부 상태에 직접 접근할 수 없음. 호출자가 제어하게 됨.

- 의존성이란: 테스트에서 제어할 수 없어 테스트 환경과 코드 유지 보수를 어렵게 만드는 요소. 파일 시스템, 네트워크, 난수 등.
- 제어란: 의존성의 동작 방식을 결정할 수 있는 능력을 의미. 의존성을 생성하는 주체가 그 의존성을 제어한다고 할 수 있음. 의존성을 코드에서 사용하기 전에 설정할 수 있는 능력.
- 의존성 주입이란: 의존성을 코드 설계 인터페이스를 통해 내부에서 사용하는데 전달하는 행위. 의존성을 주입하는 지점을 주입지점이라고 한다. 심이라고도 함.
- 심이란: 소프트웨어의 다른 두 부분이 만나는 지점. 다른 것을 주입할 수 있다. 매개변수, 함수, 모듈 로더, 함수 재작성... 뭔소리지?
- 함수를 통한 주입은 함수 자체를 의존성으로 넣는거. 예를 들면, 유저 검증할때 이메일이랑 패스워드 검증을 해야하는데, 그게 userVerify라는 함수 하나에 다 흩어지게 두는게 아니고, userVerify(emailVerify, passwordVerify)처럼 사용하는 것
- 모듈 로더는... env에 따라 다른 모듈을 로드하는 방식으로 다른 의존성을 주입할 수 있음.
- 함수 재작성은 몽키패칭. 이미 존재하는 객체나 클래스의 메서드를 런타임에 다른 구현으로 교체하는 방법.

## 함수를 의존성으로 주입

책의 예시는 좀... 차이가 없긴 한데, 책 설명에 따르면 특정 동작을 수행하도록 만들 수 있으므로 유용하다고 함.

## 부분 적용을 이용한 의존성 주입

책의 예시는... 그냥 준비 단계에서 많은걸 해놓고 실행 단계를 간단하게 만드는 것 외에 뭐가 좋아진건지 모르겠다.

## 모듈을 이용한 주입 방법

심을 만들어서 moment를 테스트에서 원하는 결과를 반환하도록 만들고 다시 원래대로 돌려놓는 예시를 보여줌.  
일단 테스트가 프로덕션 코드를 더럽히는게 말이 안된다고 생각함 ㅋㅋㅋ

그래서 중간에 어댑터를 두라는 이야기를 하는데, 뭔 아키텍처가 줄줄 나온다...  
포트는 시스템의 내부와 외부를 연결하는 인터페이스를 의미하고, 어댑터는 포트를 통해 들어오는 요청을 처리하는 구체적인 구현체라고 한다.

## 생성자 함수를 사용하여 객체 지향적으로 전환

이것도... 그냥 준비 단계에서 많이 준비해서 실행 단계를 간단하게 하는 것 뿐 아닌가? 책 예시가 좀 더 구체적이어야 할까...?

## 객체 지향적으로 의존성을 주입하는 방법

음....

덕 타이핑 이야기가 나오는데, 인터페이스가 같아서 허용된다는 이야기인 것 같다.
