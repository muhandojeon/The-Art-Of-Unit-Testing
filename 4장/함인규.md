
# 단위테스트의 기술 4장. 모의 객체를 사용한 상호 작용 테스트

날짜: 2025년 3월 4일
분류: STUDY_LOG

## 작업 단위가 제어할 수 없는 영역(외부)에 있는 의존성을 어떻게 테스트할 수 있을까?

[스텁(stub)] : 내부로 들어오는 의존성과 연결 고리를 끊는데 사용

- 테스트 코드에 가짜 동작이나 데이터를 제공하는 가짜 모듈, 객체 함수
- 스텁은 **검증할 필요 없고** **하나의 테스트에 스텁을 여러개 사용할 수 있다.**

[목(mock)] : 외부로 나가는 의존성과 연결 고리를 끊는데 사용

- 가짜로 만든 모듈이나 객체 및 함수
- 단위 테스트에서 종료점을 나타냄 ( 작업 단위의 요구사항 )
    - **테스트당 하나의 목만 사용하는 것이 좋다.**
    - **목이 여러개라는 것은 하나의 테스트에서 여러 요구사항을 테스트한다는 의미**가 될 수 있기에.
- 호출 되었는지 **검증하는 것이 중요**

---

## 왜 이렇게 스텁과 목을 반복적으로 설명하면서 구분함을 강조하는걸까?

목을 스텁으로 착각한다면, 목을 테스트당 여러개 만들어낼 수 있는 가능성이 존재한다.

목이 여러개면 처음 만나는 목을 검증하는 단계에서 실패할 경우 해당 테스트 전체가 실패 처리된다. ( 나머지 목들은 실행 조차 안한다는 것 )

**어디에서 문제가 발생하는지 모르는 검증 룰렛 상황이 발생**하게 된다..!

결국, 검증 룰렛 상황을 미연에 방지하고자 스텁과 목을 명확히 구분할 필요가 있었다.

---

## 목을 작업 단위에 주입하는 방법 (1) :: 일반적인 방법

함수에 매개변수를 추가하여 의존성을 주입하는 방식으로 리팩토링한다.

주입할 변수의 이름은 mockXXX로 하여 테스트에 모의 함수나 객체가 있음을 명확하게 하자!

---

## 목을 작업 단위에 주입하는 방법 (2) :: 모듈에 목을 주입하는 방법

의존성 중개 계층 역할을 하는 변수를 만든다. ( dependencies )

이 변수는 기본적으로 원본 의존성( original dependencies )을 가리킨다.

테스트에서는 이 간접 계층( dependencies )에 목( Mock )을 주입( inject )해서 원본 의존성을 대체해서 사용한다.

테스트가 완료되면 의존성을 다시 원본 의존성으로 되돌리는 reset 절차가 필요하다.

---

## 목을 작업 단위에 주입하는 방법 (3) :: 함수형 스타일

### `고차함수`

함수 자체를 인자로 사용하거나 반환하는 함수의 속성

ex ) 커링, 부분 적용

### `커링`

여러 개의 인자를 받는 함수를 각 인자를 하나씩 받는 함수로 변환하는 방식

$f(a,b,c) → f(a)(b)(c)$

ex)

```tsx
// 원본 함수
function add(x: number, y: number): number {
  return x + y;
}

// 커링: add 함수를 인자 하나씩 받는 함수들로 변환
function curryAdd(x: number): (y: number) => number {
  return (y: number) => add(x, y);
}

// 커링 사용 예
const addFiveCurried = curryAdd(5); // 여기서 x가 고정됨
console.log(addFiveCurried(10));    // 15 출력, 나중에 y를 적용
```

커링은 함수의 원본 자체를 수정하여 처음부터 단일 인자 함수들의 연속으로 만든다.

### `부분적용`

원래의 함수에서 일부 인자를 고정한 새로운 함수를 만드는 것.

ex)

```tsx
// 원본 함수
function add(x: number, y: number): number {
  return x + y;
}

function partial<T, U, R>(
  fn: (arg1: T, arg2: U) => R, 
  fixedArg: T
): (arg2: U) => R {
  return (arg2: U) => fn(fixedArg, arg2);
}

// 부분적용 사용 예
const addFivePartial = partial(add, 5); // 첫 번째 인자 5를 고정
console.log(addFivePartial(10));          // 15 출력
```

원본 함수를 수정하지 않는다. 원본 함수를 내부적으로 사용하는 새로운 함수를 만든다.

---

## 목을 작업 단위에 주입하는 방법 (3) :: 객체지향 스타일

객체 지향 스타일로 의존성을 주입하려고 할 때 어떻게 코드를 풀어내는가.

`일반적인 방법` : 생성자를 통해 클래스의 호출자가 매개변수를 전달하도록 강제한다.

`인터페이스 주입을 이용` : 주입받는 의존성 매개변수 타입을 추상 객체(인터페이스)로 정의한다.

- 호출자는 인터페이스를 구현한 구현체들을 주입할 수 있다.
- 만약에 복잡한 인터페이스라면?
    - 복잡한 인터페이스 : 구현할 거를 많이 정의한 커다란 인터페이스
    - 부분 모의 객체를 사용하자!
        - 부분 모의 객체 : 복잡한 인터페이스를 구현한 찐 의존성을 상속. 테스트하고자하는 부분만 오버라이드해서 사용하는 Fake 객체

---

3장에서 보았던 스텁은 의존성을 주입받아 실행한 작업 단위의 종료점(결과물)을 검증했었다. ( 스텁 자체는 검증하지 않음 )

4장에서는 작업단위의 종료점(요구사항)이 의존성일 경우, 해당 의존성을 가짜로 갈아끼우고 그 의존성에 끼친 영향(제대로 호출되었는지)을 검증했다.