### 4.1 상호 작용 테스트, 목, 스텁

- 상호 작용 테스트
  - 작업 단위가 제어할 수 없는 영역에 있는 의존성과 어떻게 상호 작용하고 메시지를 보내는지 확인하는 방법
  - 목: 외부로 나가는 의존성과 연결 고리를 끊는데 사용
  - 스텁: 내부로 들어오는 의존성과 연결 고리를 끊는데 사용

### 4.2 로거 함수에 의존

### 4.3 기본 스타일: 매개변수를 주입하는 방식으로 리팩터링

- 기존 함수: verifyPassword2('anything', [])
- 변경 함수: verifyPassword2('anything', [], mockLog)
- 매개변수를 추가하는 리팩터링으로 얻을 수 있는 이점
  - import 혹은 require로 함수를 불러올 필요가 없어 의존성이 줄어든다.
  - 로거 함수를 마음대로 만들어서 주입할 수 있다.

### 4.4 목과 스텁을 구분하는 것의 중요성

- 목: 작업 단위의 요구 사항 (ex. 로거를 호출한다, 이메일을 보낸다.)
- 스텁: 들어오는 정보와 동작 (ex. 데이터베이스 쿼리가 false를 반환한다. 특정 설정이 오류를 일으킨다.)
- 목은 테스트당 하나만, 스텁은 여러개 가능
- 목과 스텁을 잘 구분하면 어떤 점이 좋은가?
  - 가독성
  - 유지 보수성
    - 목과 스텁을 제대로 구분해 불필요하게 스텁을 검증하는 경우가 없게 하기
  - 신뢰성
    - 하나의 테스트에 목이 여러개 있을 때, 첫 번째 목을 검증하는 단계에서 실패하면 다른 검증을 할 수 없다.

### 4.5 모듈 스타일의 목

### 4.6 함수형 스타일에서 목

- lodash curry 함수로 만든 테스트 함수
- 커링과 부분 적용 함수의 차이

### 4.7 객체 지향 스타일의 목

### 4.8 복잡한 인터페이스 다루기

- 모든 인터페이스 함수를 오버라이드 해야 하므로 반복 코드가 생기고 코드 길이도 길어진다.
- 각 메서드를 호출할 때 전달받은 매개변수를 변수에 직접 저장해야 하므로 각 호출에 대한 매개변수를 검증하는 것이 더 번거로워 진다.
  - 매개변수가 너무 많아진다면 인터페이스 분리 원칙에 따라 나누기
- 내부 인터페이스가 아닌 서드 파티 인터페이스에 의존할 때가 많아 시간이 지나면서 테스트가 더 불안정해질 수 있다.
- 내부 인터페이스에 의존하더라도 긴 인터페이스는 변경될 가능성이 높아 테스트를 변경해야 할 이유도 많아진다.

### 4.9 부분 모의 객체
