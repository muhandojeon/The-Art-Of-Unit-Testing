### 4.1 상호 작용 테스트, 목, 스텁

- 상호 작용 테스트
  - 작업 단위가 제어할 수 없는 영역에 있는 의존성과 어떻게 상호 작용하고 메시지를 보내는지 확인하는 방법
  - 목: 외부로 나가는 의존성과 연결 고리를 끊는데 사용
  - 스텁: 내부로 들어오는 의존성과 연결 고리를 끊는데 사용

### 4.2 로거 함수에 의존

### 4.3 기본 스타일: 매개변수를 주입하는 방식으로 리팩터링

- 기존 함수: verifyPassword2('anything', [])
- 변경 함수: verifyPassword2('anything', [], mockLog)
- 매개변수를 추가하는 리팩터링으로 얻을 수 있는 이점
  - import 혹은 require로 함수를 불러올 필요가 없어 의존성이 줄어든다.
  - 로거 함수를 마음대로 만들어서 주입할 수 있다.

### 4.4 목과 스텁을 구분하는 것의 중요성

- 목: 작업 단위의 요구 사항 (ex. 로거를 호출한다, 이메일을 보낸다.)
- 스텁: 들어오는 정보와 동작 (ex. 데이터베이스 쿼리가 false를 반환한다. 특정 설정이 오류를 일으킨다.)
- 목은 테스트당 하나만, 스텁은 여러개 가능
- 목과 스텁을 잘 구분하면 어떤 점이 좋은가?
  - 가독성
  - 유지 보수성
    - 목과 스텁을 제대로 구분해 불필요하게 스텁을 검증하는 경우가 없게 하기
  - 신뢰성
    - 하나의 테스트에 목이 여러개 있을 때, 첫 번째 목을 검증하는 단계에서 실패하면 다른 검증을 할 수 없다.

### 4.5 모듈 스타일의 목

### 4.6 함수형 스타일에서 목

- lodash curry 함수로 만든 테스트 함수
- 커링과 부분 적용 함수의 차이

### 4.7 객체 지향 스타일의 목

### 4.8 복잡한 인터페이스 다루기

- 모든 인터페이스 함수를 오버라이드 해야 하므로 반복 코드가 생기고 코드 길이도 길어진다.
- 각 메서드를 호출할 때 전달받은 매개변수를 변수에 직접 저장해야 하므로 각 호출에 대한 매개변수를 검증하는 것이 더 번거로워 진다.
  - 매개변수가 너무 많아진다면 인터페이스 분리 원칙에 따라 나누기
- 내부 인터페이스가 아닌 서드 파티 인터페이스에 의존할 때가 많아 시간이 지나면서 테스트가 더 불안정해질 수 있다.
- 내부 인터페이스에 의존하더라도 긴 인터페이스는 변경될 가능성이 높아 테스트를 변경해야 할 이유도 많아진다.

### 4.9 부분 모의 객체

### 느낀점
- mock 과 stub 의 차이에 대해 계속적으로 이야기하고 있어서 조금 더 다른 자료들을 찾아보았다.
- https://martinfowler.com/articles/mocksArentStubs.html

```
[주요 요약]
* Meszaros uses the term Test Double as the generic term for any kind of pretend object used in place of a real object for testing purposes. The name comes from the notion of a Stunt Double in movies. (One of his aims was to avoid using any name that was already widely used.) Meszaros then defined five particular kinds of double:

Meszaros는 테스트 목적으로 실제 객체 대신 사용되는 모든 종류의 척 객체의 일반적인 용어로 테스트라는 용어를 두 배로 사용합니다. 이름은 영화에서 스턴트 더블이라는 개념에서 비롯됩니다. (그의 목표 중 하나는 이미 널리 사용 된 이름을 사용하지 않는 것이 었습니다.) Meszaros는 5 가지 특정 종류의 두 배를 정의했습니다.

* Dummy objects are passed around but never actually used. Usually they are just used to fill parameter lists.
더미 물체는 통과되지만 실제로 사용되지 않았습니다. 일반적으로 매개 변수 목록을 채우는 데 사용됩니다.

* Fake objects actually have working implementations, but usually take some shortcut which makes them not suitable for production (an in memory database is a good example).
가짜 객체는 실제로 작업 구현이 있지만 일반적으로 일부 바로 가기를 사용하여 프로덕션에 적합하지 않습니다 (메모리 데이터베이스는 좋은 예입니다).

* Stubs provide canned answers to calls made during the test, usually not responding at all to anything outside what's programmed in for the test.
스터브는 테스트 중에 이루어진 통화에 대한 통조림 답변을 제공하며, 일반적으로 테스트를 위해 프로그래밍 된 내용 외부에 전혀 응답하지 않습니다.

* Spies are stubs that also record some information based on how they were called. One form of this might be an email service that records how many messages it was sent.
스파이는 부름을받는 방법에 따라 일부 정보를 기록하는 스터브입니다. 이것의 한 형태는 전송 된 메시지 수를 기록하는 이메일 서비스 일 수 있습니다.

* Mocks are what we are talking about here: objects pre-programmed with expectations which form a specification of the calls they are expected to receive.
조롱은 우리가 여기서 이야기하는 것입니다. 개체는 그들이받을 것으로 예상되는 통화의 사양을 형성하는 기대치로 사전 프로그래밍 된 물체입니다.
```