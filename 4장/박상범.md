# 4장 모의 객체를 사용한 상호 작용 테스트

## 상호 작용 테스트, 목, 스텁

상호 작용 테스트
- 작업 단위가 제어할 수 없는 영역에 있는 의존성과 어떻게 상호 작용하고 메시지를 보내는지 확인하는 방법
- mock 함수나 mock 객체를 통해 외부 의존성을 제대로 호출했는지 검증 가늗

목
- 단위 테스트에서 종료점, 작업 단위의 요구사항을 나타냄 (e.g 로거를 호출한다. 이메일을 보낸다)
- 호출되었는지 검증 필요
- 1 테스트 1 목 (유지보수와 가독성을 위해)

스텁
- 작업 단위로 들어오는 경유지, 들어오는 정보나 동작을 나타냄 (e.g DB 쿼리가 false를 반환한다. 특정 설정이 오류를 일으킨다)
- 검증할 필요 없음
- 1 테스트 N 목

> 이번 장에서 목과 스텁의 차이점을 좀 더 명확히 설명해주는 느낌이였다

## 로거 함수에 의존

로거 함수의 호출 여부를 검증해보기 위해 이전에 스텁에서 사용했던 의존성 추상화 방법을 사용해보자.
- 매개변수 주입
- 커링 사용
- 고차함수 변환
- 모듈 의존성 추상화
- 타입이 없는 객체 주입
- 인터페이스 주입

## 매개변수 주입 방식

스텁을 만들어 외부에서 의존성으로 주입할 수 있게 변경한 것과 크게 다르지 않음

```js
const verifyPassword2 = (input, rules, **logger**) => {
```

```js
it('calls the logger with PASSED', () => {
  let written = '';
  const mockLog = {
    info: (text) => {
      written = text;
    }
  };
  
  verifyPassword2('', [], **mockLog**)
  
  expect(written).toMatch(/PASSED/);
});
```

### 모듈 의존성 주입
중간 객체인 심을 이용해, inject와 reset 모듈을 넘겨 테스트 하는 방법

이 방법은 코드가 더 많아지고 복잡해 보일 수 있지만 의존성을 쉽게 바꿀 수 있고 afterEach와 같은 메서드 사용하면 각 테스트가 끝날 때 마다 의존성을 초기화 하기도 쉽다.

근데 문제는 프로젝트가 모듈 의존성을 주입할 수 있도록 설계되어야 이 함수를 재사용 가능한 함수로 추상화해서 반복적인 코드 줄이기가 가능하다는 것이다. 다시 말해서, 설계에 따라 사용 가능 여부가 달라짐

이외 나머지 방식은 고개 끄덕이면서 읽었구 큰 인사이트를 얻진 못해서 넘어가겠습니다

### 총평
목과 스텁이 어떤게 다른지 좀 더 설명해주고, 목과 스텁을 구분하는 것에 대한 중요성에 대해 한번 더 짚고 넘어가서 좋았습니다

스텁과 마찬가지로 목을 작업 단위에 주입하는 방식을 설명하는건 이전 장과 비슷해서 그저 고개를 끄덕이며 읽었습니다
