## **유지 보수성이 높은 테스트 코드 작성하기**

**유지 보수성이란?**

- **정의**: 테스트를 얼마나 자주 변경해야 하는지를 판단하는 척도
- **목표**: 테스트 변경 횟수를 **최소화**하는 것

## **테스트를 왜 자주 고치게 될까?**

### **테스트가 실패해서 수정을 해야 하는 경우**

**1. 실제 실패 (실제 버그로 인한 테스트 실패)**

- **프로덕션 코드에 진짜 버그**가 존재하여 테스트가 실패함
- 이 경우 테스트는 유효함 → 수정 대상이 아님

**2. 거짓 실패 (불필요하게 실패한 테스트)**

- 테스트가 실패했지만, **실제 버그는 아님**
- 이럴 땐 테스트를 괜히 고치게 되는 상황 → 가능한 **피해야 함**

### **거짓 실패의 주요 원인**

**Case 1. 테스트 자체에 버그가 있는 경우**

- 잘못 작성된 테스트로 인해 실패

**Case 2. 새로운 기능이 기존 테스트와 충돌하는 경우**

- 기존 테스트가 더 이상 **의미 없을 수 있음**
- 테스트는 **기능 변경에 맞춰 삭제될 수도 있음**

**Case 3. 테스트 대상 코드의 사용 방식이 바뀐 경우**

- 예: 함수의 인자나 객체 생성 방식이 변경됨
- **기능은 그대로인데 테스트만 깨짐**
- 이런 실패는 **팩토리 함수**나 **헬퍼 함수**로 예방 가능

### **팩토리 함수로 유지 보수성 높이기**

**테스트 대상 객체의 생성 방식이 바뀌는 경우**

- 테스트에서 동일한 객체를 반복해서 만들어야 할 때가 많음
- 그런데 객체 생성 인터페이스가 바뀐다면?
- 객체를 생성하는 부분을 모두 찾아 테스트 전체를 고쳐야 하는 상황 발생

**✅ 해결책: 팩토리 함수 도입**

```jsx
const makePasswordVerifier = (
  rules = [],
  logger = makeFakeLogger()
) => {
  return new PasswordVerifier(rules, logger);
};
```

- 객체 생성 방식을 **한 곳에 모아서 관리**
- 생성 방식이 바뀌면 이 함수 **한 줄만 수정하면 됨**
- 테스트 전체를 건드릴 필요 없음 → 유지 보수성 향상!

### 헬퍼 함수로 유지 보수성 높이기

테스트가 독립적이지 않고 서로 영향을 주는 경우

- **순서가 정해진 테스트** : 어떤 테스트가 이전 테스트의 실행 여부에 따라 결과가 달라지는 상황
- 예 : 다른 테스트 때문에 설정 값이 바뀌거나 공유 변수 같은 자원의 상태 값이 변경됨.
- **대부분의 테스트 러너가 테스트를 항상 특정 순서로 실행하지 않는다. → 순서 보장 ❌**

**✅ 해결책: 재사용 가능한 헬퍼 함수 도입**

- 현재 테스트에 필요한 설정 값을 초기화하는 함수를 만들어서 테스트마다 독립적으로 호출해 사용하자.
- 매 테스트마다 새로 설정 값을 만들기 때문에 자원의 공유가 없는 독립적인 상태가 된다.

## 유지 보수성을 높이는 리팩토링 방법

시간이 지나도 테스트가 처음의 견고함을 유지하고 유지 보수성을 오래도록 보장할 수 있는 리팩터링 방법

### 1. private, protected 메서드 사용하지 않기

- 단위 테스트의 목표는 “이 객체가 외부적으로 기대한 대로 동작하는가?“를 확인하는 것
- 테스트는 “외부 동작”만 신경써야 한다. → 내부 로직이 어떻게 돌아가는지는 신경 안써도 됨.

**만약에 private, protected 같은 접근 제한된 메서드를 테스트해보고 싶다면 어떻게 해?**

**✅ 해결책1. 해당 메서드를 public으로 만든다.**

- 테스트가 필요할 정도로 중요한 기능이라면 외부에 노출되어 쓰일만한 기능일수도!

**✅ 해결책2. 해당 메서드를 새로운 클래스나 모듈로 분리한다.**

- 메서드에 독립적으로 동작할 수 있는 로직이 많이 포함되어있거나, 해당 메서드와 관련된 특정 상태 값을 사용한다면..
- 외부 클래스/모듈로 분리하고 이 분리된 것만 따로 테스트하자.
- 원래 클래스는 이 분리된 클래스/모듈을 의존성 주입을 통해 사용하면 된다.

**✅ 해결책 3: stateless하다면 static 또는 유틸 함수로 빼기**

- 메서드가 stateless하다 = 상태를 가지지 않는 순수함수
- 이 경우에는 static 혹은 유틸 함수로 빼버리는 것이 테스트하기 훨씬 쉽다.

### 2. 테스트코드에서도 DRY 원칙 고수하기 | 초기화 함수 사용하지 않기

DRY(Don’t Repeat Yourself) 원칙은 프로덕션 코드뿐만 아니라 테스트 코드에도 적용되어야 한다.

코드에 중복이 있으면 어떤 변경이 발생했을 때 모든 중복된 부분을 함께 수정해야 하기 때문!

테스트에서 중복을 줄이기 위해 beforeEach() 등 초기화 함수를 사용한다.

하지만, 초기화 함수는 잘못 사용되기 쉬워 개발자가 이를 원래 의도와 다르게 사용할 가능성이 높다.

→ 결국 테스트 가독성이 떨어지고 유지 보수도 어려워진다.

**✅ 초기화 함수를 사용하지 않는 해결책 : 팩토리 함수 / 헬퍼 함수를 사용한다.**

- 초기화 함수는 객체를 초기화할 때만 유용!
- 현재 테스트에 필요한 설정 값을 초기화하는 함수를 만들어서 테스트마다 독립적으로 호출해 사용하자.

### 3. 매개변수화된 테스트 사용하기

- jest에서는 `test.each()`나 `it.each()` 를 사용할 수 있다. ( 이차원 배열로 입력값과 결과값을 전달하는 함수 )
- 이 방식은 동일한 테스트 시나리오에서 입력값과 결과값이 다른 경우에만 사용하도록 하자.

## 과잉 명세된 테스트

**과잉 명세된 테스트** : 코드의 외부 동작을 확인하는 것이 아니라, 코드 내부가 어떻게 구현되어야 하는지까지 검증하는 테스트

이런 테스트는 지나치게 구체적이고 복잡해서 코드를 변경할 때 테스트를 자주 수정해야하는 문제 → 유지보수성 안좋다!

### 예시1 : 테스트가 객체의 내부 상태만 검증하는 경우

작업 단위의 종료점을 확인하는 대신 클래스나 모듈의 내부 함수가 호출되었는지만 검증하는 것.

- 작업 단위의 종료점을 검증하지 않는 것은 안티 패턴
- 테스트를 위한 테스트일 뿐이며, 의미가 없다.

**✅ 해결책. 일단 종료점부터 찾고, 종료점을 검증하도록 수정하자.**

- 실제 종료점은 수행하고자 하는 테스트 종류가 무엇이냐에 따라 달라질 수 있다.
- 종료점에 따른 테스트 유형
    - 값 기반 테스트 : 호출된 함수의 반환 값을 확인 하는 방식
    - 상태 기반 테스트 : 진입점 함수와 같은 레벨에 위치하는 형제 함수나 속성을 확인하기
    - 서드 파티 테스트 : 코드 내부에서 fire-and-forget 위치를 찾아야한다.
        - fire-and-forget : 작업이나 명령을 실행한 후 결과를 기다리지 않고 바로 다음 작업을 수행하는 방식 ( 외부로 향하는 종료점 )

### 예시2 : 결과와 순서를 지나치게 세밀하게 검증하는 경우

전체 목록과 각 항목을 한꺼번에 검증하면 목록의 사소한 변경에도 테스트를 수정해야 하는 부담이 생긴다.

한 번에 모든 것을 검증하려고 하지 말고, 검증을 여러 작은 검증 구문으로 나누어 각각의 측면을 명확하게 확인하는 것이 좋다.

이 경우에 대한 예시를 더 세밀하게 나누면 다음과 같다.

1. 배열의 순서와 결과를 모두 검증하는 경우
    - 유지보수가 힘든 예시
        - 배열의 길이가 변경될 경우
        - 객체 배열의 경우 → 객체에 속성이 추가되거나 삭제되는 경우
        - 배열의 순서가 변경될 때
2. 단위 테스트에서 반환 값이나 속성에 대해 하드코딩 된 정확한 문자열을 사용하여 검증하는 것
    - 문자열의 완벽 일치 여부로 검증한다면 문자열의 작은 변화에도 테스트 수정이 필요할 수 있다.
    - 문자열의 완벽 일치 여부보다는 필요한 내용의 포함 유무를 확인 가능한지의 방향으로 검증하자.
