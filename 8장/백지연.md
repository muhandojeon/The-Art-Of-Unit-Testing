# 8장 유지 보수성

테스트 유지 보수성을 높이는 방법 소개

## 테스트 실패로 코드 변경

### 프로덕션 코드의 API 변경

**객체를 만드는 과정을 팩토리 함수로 분리해야 한다.**  
나중에 변경 사항이 발생하면 팩토리 함수만 수정하면 되니까 테스트는 수정할 필요가 없다.  
객체를 생성하고 미리 설정하는 함수를 팩토리 함수 또는 팩토리 메서드라고 한다.  
이게 더 발전한 패턴은 객체의 어머니(Object Mother) 패턴이다.

### 다른 테스트가 변경되었을 경우

테스트가 독립적이지 않으면 문제가 발생한다.  
같은 기능을 검증하더라도 각 테스트는 서로 격리된 공간에서 실행해야 한다.

**순서가 정해진 테스트**  
= 이전 테스트의 여부에 실행 따라 테스트 결과 달라짐   
= 순서에 대한 의존성을 삭제하는 방향으로 리팩터링 필요  
= **헬퍼 함수를 만들고**, 테스트 실행 전후로 `beforeEach()`나 `afterEach()`를 사용해 **공유 자원 리셋**해야 함

외부 자원(메모리 내 공유 변수, 데이터베이스)을 변경했는데 다른 테스트에서 그 값을 참조한다면, 두 테스트는 실행 순서에 영향을 받는다.  
대부분의 테스트 러너는 테스트를 항상 특정 순서로 실행하지 않는다.  
즉, 테스트가 이전과 동일한 순서로 실행되지 않을 수 있다.  

## 유지 보수성을 높이는 리팩터링 방법

### private 또는 protected 메서드 사용하지 않기

`private` 또는 `protected`는 메서드 접근을 제한하는 용도로 사용한다.  
구현 세부 사항을 숨기고 구현이 변경되더라도 **외부에서 보이는 동작은 바뀌지 않도록 하기 위함**이다.

`private` 메서드  
= 홀로 존재할 수 없고 결국 호출해야만 실행된다.  
= 외부 인터페이스로 시작하는 더 큰 작업의 일부  
= 시스템 내에서 이 메서드를 호출하는 부분을 찾아야 한다.  

`private` 메서드 테스트  
= 추상화가 부족하다는 신호  
= 해당 메서드를 `public`으로 만들거나 별도의 클래스로 분리해야 한다는 의미  

> [!IMPORTANT]
> **`private` 메서드는 테스트하지 않는 것이 좋으며, 외부에서 관찰할 수 있는 `public` 메서드를 검증해야 한다.**  
> `public` 메서드에 대한 테스트를 작성하고, `public` 메서드가 더 작은 `private` 메서드를 호출하도록 리팩터링한다.

### 테스트에서도 DRY 원칙 고수

DRY 원칙은 동일한 코드를 반복하지 말라는 것이다.  
**헬퍼 함수를 사용하면 중복을 줄일 수 있다.**  
준비(arrange)와 검증(assert)에서 반복되는 사항을 헬퍼 메서드로 추상화해야 한다.

### 초기화 함수를 사용하지 않기

중복 제거를 위해 각 테스트 전에 실행하는 `beforeEach()` 함수가 초기화 함수다.  
> [!IMPORTANT]
> **가급적이면 초기화 함수 대신 팩토리 메서드와 헬퍼 함수를 사용하는 것이 좋다.**

### 매개변수화된 테스트로 중복 코드 제거

매개변수화 패턴 = `beforeEach()`에 있어야 할 설정 로직을 각 테스트의 준비(arrange) 단계로 옮기는 것     

> [!TIP]
> 다양한 테스트 프레임워크에서 매개변수화된 테스트를 지원한다.  
> ex. 제스트의 경우 `test.each()`나 `it.each()`  
> https://vitest.dev/api/#test-each  

```js
// 서로 다른 입력과 결과로 동일한 테스트를 두 번 작성
describe('sum with regular tests', () => {
  test('sum number 1', () => {
    const result = sum('1');
    expect(result).toBe(1);
  });
  test('sum number 2', () => {
    const result = sum('2');
    expect(result).toBe(2);
  });
});

// 중복을 제거한 초기화 및 검증
// test.each() 함수로 배열을 전달
describe('sum with regular tests', () => {
  test.each([
    ['1', 1],
    ['2', 2]
  ])('add %s, returns that number', (input, expected) => {
    const result = sum(input);
    expect(result).toBe(expected);
  });
});
```
> [!CAUTION]
> 동일한 테스트 시나리오에서는 입력과 결과가 다를 때만 사용하도록 주의한다.

## 과잉 명세된 테스트

### 목을 사용한 내부 동작 과잉 명세

작업 단위의 종료점 대신 함수 호출만 검증하는 것은 안티 패턴이다.  
메서드가 값을 반환한다면 그 메서드를 모의 함수로 만들지 않는 편이 좋다.

### 결과와 순서를 지나치게 세밀하게 검증

결과와 순서가 그다지 중요하지 않다면 결과에 특정 값이 포함되어 있는지만 확인하면 된다.
