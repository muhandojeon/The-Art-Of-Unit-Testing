# 유지 보수성

## 테스트 실패로 코드 변경
실제 버그로 발생한 실패를 실제 실패, 프로덕션 코드의 버그가 아닌 다른 이유로 발생하는 실패를 거짓 실패라고 부른다.

거짓 실패가 중요한데, 기능 변경으로 인해 테스트가 실패한다면 이는 버그가 아니므로 거짓 실패다. 반영하면 된다. 만약 더 이상 유효하지 않다면 테스트를 삭제해도 된다.

기능이 동일해도 사용법이 바뀌면 테스트가 실패할 수 있다. 기존 api와 호환되지 않는 bc 발생시 문제가 되므로, api를 만족하는 객체를 만드는 부분을 별도의 팩토리 함수로 추상화한다.  
그러면 팩토리 함수만 수정할 경우 모든 테스트가 api 변경에 대응할 수 있다.  

테스트가 독립적이지 않고 서로 영향을 주면 의도치 않게 테스트가 실패할 수 있다. 서로 격리된 공간에서 실행되어야 함.  
이전 테스트의 실행 여부에 따라 결과가 달라지는 테스트는 잘못된 것임.  
외부 자원을 변경, 초기화하는 헬퍼 함수들을 만들어놓고 사용해야 함.

## 유지 보수성을 높이는 리팩터링 방법
private, protexted 메서드 사용하지 않기. private 메서드는 시스템 내부의 약속을 테스트하는 것과 같다. 테스트는 외부에 노출되는 것을 대상으로 하므로 적합하지 않음.  
애초에 private 역시 public 메서드를 위한 동작일 것이므로, 우리는 public 메서드만 테스트하면 된다.

따라서 메서드를 public으로 만들거나, 별도의 클래스나 모듈로 분리하자.

중복을 줄이자. 다만 너무 과도한 추상화는 가독성을 해칠 수 있다.

beforeEach와 같은 초기화 함수를 사용하지 말자. 길어지면 이게 왜 초기화되는지 알지 못하게 될 수 있다. 그냥 헬퍼 함수를 사용해도 된다.  

test.each()를 사용하면 테스트를 매개변수화할 수 있다. 근데... 써봤는데 가독성이 별로라고 느꼈다.

## 과잉 명세된 테스트

코드의 외부 동작을 확인하는 것이 아니라, 코드 내부가 어떻게 구현되어야 하는지까지 검증하는 테스트. 목을 여러 개 만들어 사용하거나, 스텁을 목처럼 사용하거나 등등... 종료점만 테스트하자.

결과와 순서를 지나치게 세밀하게 검증하지 않도록 하자. 한 번에 모든 것을 검증하지 말고, 작은 검증 구문으로 나눠서 각각을 명확하게 확인하자.  



