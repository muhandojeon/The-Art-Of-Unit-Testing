# 첫 번째 단위 테스트

- test 파일 접미사
  - 저자는 test를 spec의 간단한 버전이라고 생각함

> E2E 테스트가 있는 애플리케이션 환경에서는 test를 유닛과 통합 테스트, spec을 E2E 테스트로 분류하기도 하더라구용
> 저도 이렇게 하는 걸 선호하긴 함
> > Cypress 였나 Playwright도 이걸 권장했던 걸로 기억했는데 문서는 못찾음

- 제스트는 글로벌 함수로 불러온다 (ex. describe, it, expect)

> 이거에 갈증을 느껴 직접 임포트문을 사용하는 것을 선호하는 사람들도 있더라구요 (저)
> 그래서 vitest도 초반에는 글로벌 함수 사용 API를 지원하지 않았던 것으로 알아요
> > 그냥 안만든 상태였던 것일지도

- 테스트 라이브러리의 역할
  - 검증
  - 테스트 러너
  - 테스트 리포터
  - 격리 (Mock, Stub, Spy)

- 다른 테스트 라이브러리의 구조
  - xUnit 스타일
    - 스몰토크의 단위 테스트 프레임워크인 SUnit이 시초
    - Java -> JUnit
  - TAP (Test Anything Protocol)
  - 제스트는 둘 다 아니지만, 둘 다에 맞게 프로토콜을 맞출 수 있는 도구가 존재

## AAA 패턴

- Arrange, 준비
- Act, 실행
- Assert, 검증

테스트 코드를 작성할 때 위 순서대로 구획을 나누면 읽기 편함

## USE 전략

테스트 이름을 잘 지어야 코드를 읽는 이의 머릿속을 물음표가 아닌 느낌표로 채울 수 있음

- Unit, 테스트하려는 대상
- Senario, 입력 값이나 상황에 대한 설명
- Expectation, 기댓값이나 결과에 대한 설명

```ts
test('verifyPassword, given a failing rule, returns errors', () => {})

// 테스트 대상을 명시하고, 어떤 입력이나 상황이 주어지면, 어떤 결과로 이어져야 하는지 간결하고 명확하게
```

## 문자열 비교와 유지 보수성

- 테스트 코드는 동일한 비즈니스 로직에서 항상 같은 결과를 보장해야 하기에 테스트의 유지 보수성과 불안전성을 줄이는 것을 우선시해야 한다
  - 중요한 것은 메시지가 담고 있는 의미

```ts
expect(result).toBe('error')

// 위 보다는
expect(result).toContain('error') // 혹은 Match와 Regex
```

## Describe

- USE 전략에 맞게 구획을 나눌 수 있음

- 저자는 테스트 상황이 명확할 때 test만을,
- 동일한 시나리오에서 동일한 진입점에 대해 여러 결과를 검증할 때는 descrive를 사용

## it

- 영어 테스트는 자연스럽게 읽힘

> 저는 영어로 테스트 명을 쓰는 경우에는 it, 한글은 test를 좋아하긴 해요


## 1 test n expect

- 위의 expect(assert)문이 실패하면 아래 expect는 실행되지 않음
- 이를 확인하기 위해 주석처리를 하는등 하지만, 이는 좋지 않음
- 이러한 행동을 `검증 룰렛`이라고 함
- 테스트를 실행할 때 많은 혼란과 거짓 양성을 초래할 수 있음

-> 그러니 추가 검증 코드를 별도의 테스트 케이스로 분리하고 이해하기 쉬운 이름을 붙이는 것이 더 남


## beforeEach

- 제스트는 기본적으로 단위 테스트를 병렬로 실행

- 저자는 테스트 코드의 모든 부분을 공통 로직으로 분리하는 것을 선호하지 않음
- 중복되는 코드를 재사용 가능한 코드로 분리하는 것은 프로그래머라면 누구나 좋아하는, 직업적 본능이지만
- 테스트 코드에 한해서는 `모든 로직을 공통화해 버리면 오히려 코드 결합도가 과도하게 높아지고 유연성이 떨어져` 추후에 유지보수가 필요할 수 있음
-> 테스트 수정보다 공통 로직을 사용하는 다른 코드에 영향이 있을지 확인하는, 배보다 배꼽이 더 커지는 상황을 피하기 위해 섣부른 분리는 하지 말자

> 공감됨, 한 테스트 케이스에서 명확하게 시작하고 끝내는 것이 좋다고 느껴짐

- "누군가 먼저 beforeEach 함수에 온갖 것을 다 넣어둔 흔적이 보이면, 이는 일종의 면죄부가 되어 죄책감을 덜 느껴 '에라 모르겠다. 나도 일단 놓고 보자'고 생각하게 된다"

> 실용주의 프로그래머에서 말한, 소프트웨어의 깨진 유리창 법칙 ㅋㅋㅋ
> > 사례 공유

## 팩토리 함수

- beforeEach 대신 팩토리 함수를 적절히 이용 가능

- 객체가 어떻게 생성되는지는 몰라도 언제 생성되고 어떤 중요한 매개변수로 초기화되는지는 알 수 있다. 모든 것이 명확하다.
  - 캡슐화

## 다양한 입력 값

- test.each

```ts
test.each([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
])('adds %i and %i to equal %i', (a, b, expected) => {
  expect(a + b).toBe(expected)
})
```

- 이 패턴은 효율적이고 유연하지만, 잘 못 사용하면 테스트 가독성을 해치고 유지 보수를 어렵게 만든다.

## 예정된 오류

- `expect().toThrowError`

