# 2장 첫 번째 단위 테스트

## 제스트 소개

### 테스트 파일 생성

제스트는 파일을 찾을 때 기본적으로 다음 규칙을 따른다.

- `__tests__` 폴더가 있으면 그 안의 모든 파일을 이름과 상관없이 테스트 파일로 간주하고 불러온다.  
- 프로젝트의 최상위 폴더 아래에 있는 모든 폴더를 대상으로 `*.spec.js` 또는 `*.test.js`로 끝나는 파일을 재귀적으로 찾는다.

> [!IMPORTANT]
> 테스트 파일 위치  
> (1) 테스트 대상 파일 옆에 두기  
> (2) 별도의 폴더 아래에 모든 테스트 파일 두기  

> [!NOTE]  
> 헬퍼 파일을 테스트 폴더 근처에 두면 편리하다는 이유로 필자는 후자를 선호함

> 저는..
```markdown
features/
└── user/
    └── lib/
        ├── utils.ts
        └── utils.spec.ts
```

### 제스트 실행

`jest --watch` 명령어를 사용하면, 제스트가 변화를 감지하고 변경된 파일에 대한 테스트를 자동으로 실행한다.

```json
"scripts": {
  "test": "jest",
  "testw": "jest --watch", // 추적 모드 활성화
}
```

이렇게 하면 코딩을 계속하면서 테스트 통과를 실시간으로 확인할 수 있다.

> https://vitest.dev/guide/features#watch-mode  
> Vitest도 watch mode 가능

> https://marketplace.visualstudio.com/items?itemName=vitest.explorer  
> vscode 익스텐션도 활용 중   

### 준비-실행-검증 패턴 (Arrange-Act-Assert)

테스트를 **구조적**으로 작성할 수 있도록 도와주는 패턴

- 준비 : 테스트하려는 시스템과 종속성을 원하는 상태로 설정
- 실행 : 메서드를 호출하고 필요한 데이터 전달
- 검증 : 결과 검증

### USE 전략

테스트 이름을 잘 짓기 위해 고려해야 할 3가지 요소

- Unit : 테스트하려는 대상 (ex. 함수)
- Scenario : 입력 값이나 상황에 대한 설명 (ex. 결과로 false를 반환하는 상황)
- Expectation : 기댓값이나 결과에 대한 설명 (ex. 에러 메시지를 반환)

```js
// USE 전략 적용 예시
test('verifyPassword, given a failing rule, returns errors', () => {});
```

### 문자열 비교와 유지 보수성

문자열 동등 비교보다는 정규 표현식을 사용하는 `toMatch(/string/)` 패턴이나 `toContain()` 메서드를 사용하는 게 좋다.    
디자인 관점에서 마침표가 하나 빠지더라도 메시지 의미가 같다면 테스트 결과에 영향을 주지 않아야 한다.

### 함수

- `describe()` 함수로 테스트 그룹을 만들면 가독성이 높아지고, 독립적인 테스트 환경을 보장한다. 중첩 구조도 가능하다.  
- `it()` 함수는 `test()` 함수의 별칭이고, `describe()`와 자연스럽게 이어진다.
- `beforeEach()` 함수는 코드 중복을 피하는 데 도움이 되지만, 스크롤 피로감의 원인이 될 수도 있기 때문에 팩토리 함수를 사용하면 더 좋다.

### 스냅샷

제스트에는 스냅샷이라는 기능이 있다.  
리액트에서 컴포넌트를 렌더링한 후 현재 렌더링 결과를 저장된 스냅샷과 비교하여 모든 속성과 HTML이 일치하는지 확인할 수 있다.  

> [Vitest에서의 스냅샷 테스트 개념과 활용](https://puddingcamp.com/page/6236d209-638b-43ef-86d4-c4c7ec77e47b)
>> **변경이 잦지 않은 핵심 UI 구조를 위주로 스냅샷을 생성하고, 자주 변하는 영역은 다른 방식으로 테스트**  
>> 컴포넌트가 현재 시각을 표시하거나 무작위 난수를 생성해 DOM 구조를 바꾼다면, 스냅샷이 매 실행마다 달라집니다.  
>> 이럴 땐 Vitest의 `vi.useFakeTimers()`, `vi.fn()` 등을 통해 해당 부분을 Mock 처리하여 일정한 값이 들어가도록 만듭니다.  
>> 너무 거대한 컴포넌트 전체를 스냅샷으로 찍으면, 작은 부분 하나만 변경되어도 전체가 깨집니다.  
>> UI가 자주 변하는 일부 영역은 제외하고, 상대적으로 안정적인 부모 레이아웃 구조만 스냅샷을 찍을 수도 있습니다.  
>> 스냅샷 테스트는 UI 변경 이력을 빠르게 추적하는 용도로는 좋지만, 자주 구조가 달라지면 번거로워질 수 있습니다.

> https://vitest.dev/guide/snapshot
