# 2장 첫 번째 단위 테스트

## 제스트 소개

### 테스트 파일 생성

제스트는 파일을 찾을 때 기본적으로 다음 규칙을 따른다.

- `__tests__` 폴더가 있으면 그 안의 모든 파일을 이름과 상관없이 테스트 파일로 간주하고 불러온다.  
- 프로젝트의 최상위 폴더 아래에 있는 모든 폴더를 대상으로 `*.spec.js` 또는 `*.test.js`로 끝나는 파일을 재귀적으로 찾는다.

> [!IMPORTANT]
> 테스트 파일 위치  
> (1) 테스트 대상 파일 옆에 두기  
> (2) 별도의 폴더 아래에 모든 테스트 파일 두기  

> [!NOTE]  
> 헬퍼 파일을 테스트 폴더 근처에 두면 편리하다는 이유로 필자는 후자를 선호함  

### 제스트 실행

`jest --watch` 명령어를 사용하면, 제스트가 변화를 감지하고 변경된 파일에 대한 테스트를 자동으로 실행한다.

```json
"scripts": {
  "test": "jest",
  "testw": "jest --watch", // 추적 모드 활성화
}
```

이렇게 하면 코딩을 계속하면서 테스트 통과를 실시간으로 확인할 수 있다.

> https://vitest.dev/guide/features#watch-mode  
> Vitest도 watch mode 가능

> https://marketplace.visualstudio.com/items?itemName=vitest.explorer  
> vscode 익스텐션도 활용 중   

### 준비-실행-검증 패턴 (Arrange-Act-Assert)

테스트를 **구조적**으로 작성할 수 있도록 도와주는 패턴

- 준비 : 테스트하려는 시스템과 종속성을 원하는 상태로 설정
- 실행 : 메서드를 호출하고 필요한 데이터 전달
- 검증 : 결과 검증

### USE 전략

테스트 이름을 잘 짓기 위해 고려해야 할 3가지 요소

- Unit : 테스트하려는 대상 (ex. 함수)
- Scenario : 입력 값이나 상황에 대한 설명 (ex. 결과로 false를 반환하는 상황)
- Expectation : 기댓값이나 결과에 대한 설명 (ex. 에러 메시지를 반환)

```js
// USE 전략 적용 예시
test('verifyPassword, given a failing rule, returns errors', () => {});
```

### 문자열 비교와 유지 보수성

문자열 동등 비교보다는 정규 표현식을 사용하는 `toMatch(/string/)` 패턴이나 `toContain()` 메서드를 사용하는 게 좋다.    
디자인 관점에서 마침표가 하나 빠지더라도 메시지 의미가 같다면 테스트 결과에 영향을 주지 않아야 한다.

### 함수

- `describe()` 함수로 테스트 그룹을 만들면 가독성이 높아지고, 독립적인 테스트 환경을 보장한다. 중첩 구조도 가능하다.  
- `it()` 함수는 `test()` 함수의 별칭이고, `describe()`와 자연스럽게 이어진다.
- `beforeEach()` 함수는 코드 중복을 피하는 데 도움이 되지만, 스크롤 피로감의 원인이 될 수도 있기 때문에 팩토리 함수를 사용하면 더 좋다.

### 스냅샷

제스트에는 스냅샷이라는 기능이 있다.  
리액트에서 컴포넌트를 렌더링한 후 현재 렌더링 결과를 저장된 스냅샷과 비교하여 모든 속성과 HTML이 일치하는지 확인할 수 있다.  

> [Vitest에서의 스냅샷 테스트 개념과 활용](https://puddingcamp.com/page/6236d209-638b-43ef-86d4-c4c7ec77e47b)  
> https://vitest.dev/guide/snapshot
