## 7장 신뢰할 수 있는 테스트

좋은 테스트의 세가지 특성 : 신뢰성, 유지보수성, 가독성

그 중 신뢰성이 좋은 테스트의 첫번쨰 기준임   

테스트를 신뢰할 수 없다면 테스트를 실행하는 의미가 없음 => 테스트가 실패해도 이를 수정하거나 코드 고치는 것도 역시나 의미 없음 => 결국 테스트를 유지보수 하는 것도 무의미 

## 테스트를 신뢰할 수 있는지 판단하는 방법

테스트를 신뢰하지 않는 상황
- 테스트가 실패했지만 신경 쓰지 않는 경우 <= 거짓 양성(실제로 코로나 걸리지 않았는데, 코로나 검사 했더니 양성 나오는 상황)
- 테스트 결과를 무시해도 괜찮다고 여기는 경우
- 테스트가 통과했지만 의심스러운 경우 <= 거짓 음성(실제로는 코로나에 걸렸는데, 코로나 검사 했더니 음성 나오는 상황)

테스트 신뢰하는 상황
- 테스트가 실패했을 때, 코드의 무언가가 잘못되었을까 봐 진심으로 걱정하고 쉽게 넘어가지 않는 경우
- 테스트가 통과한 경우, 수동으로 테스트하거나 디버깅할 필요가 없다고 여김

## 테스트가 실패하는 이유

- 프로덕션 코드에서 실제 버그가 발견된 경우
- 테스트가 거짓 실패를 일으키는 경우
- 기능 변경으로 테스트가 최신 상태가 아닌 경우
- 테스트가 다른 테스트와 충돌하는 경우
- 테스트가 불안정한 경우

한번쯤은 겪어봤던 익숙한 사례들과 함께 설명하며 예방법을 알려줌

## 단위 테스트에서 불필요한 로직 제거

테스트 코드에 복잡한 로직이 포함되면 그만큼 테스트 자체에 버그가 생길 확률이 높음

- switch, if, else 문
- forEach, for, while 루프
- 문자열 연결(+ 기호)
- try/catch 블록

## Assert 문에서의 로직: 동적 기댓값 생성

검증 단계에서 기댓값을 동적으로 생성하지 말고 가능하면 하드코딩된 값 사용하기 => 주로 단위 테스트에 해당되는 이야기

상위 수준의 테스트는 기댓값을 동적으로 만들 때도 많은데, 이는 가능한 한 피해야 함

"이러면 문자열 'abc'를 두 번 반복하게 되잖아! 이전 테스트에서는 그럴 필요가 없었는데" => 신뢰할 수 없는 테스트의 유지보수성이 높다고 해도 그게 무슨 소용이냐!

## 다른 형태의 로직
```js
describe("isName", () => {
  const namesToTest = ["firstOnly", "first second", ""]; // 여러 입력 값을 정의

  it('correctly finds out if it is a name', () => {
    namesToTest.forEach((name) => {
      const result = isName(name);
      if (name.includes(' ')) {
        expect(result).toBe(true);
      } else {
        expect(result).toBe(false);
      }
    });
  });
});
```

단순한 테스트와 복잡한 테스트를 분리하여 각각의 테스트가 더 효과적으로 작동할 수 있도록 한다.

## 로직이 더 많이 포함된 경우

로직은 테스트 뿐만 아니라 테스트에 필요한 헬퍼 함수, 직접 작성한 가짜 객체, 테스트 유틸리티 클래스에서도 찾아볼 수 있음

> 이건 간과했다;

유틸리티 함수의 로직을 검증하는 몇가지 테스트 추가하면 잠재적인 문제 예방 가능

## 테스트가 통과하더라도 끝이 아니다

필자가 테스트가 통과하더라도 테스트를 믿지 못하는 경우
- 검증 부분이 없는 경우
- 테스트를 이해할 수 없는 경우
- 단위 테스트가 불안정한 통합 테스트와 섞여 있는 경우
- 테스트가 여러가지를 한꺼번에 검증하는 경우
- 테스트가 자주 변경되는 경우

테스트 커버리지는 그 자체로 목표가 되어서는 안 됨, 이는 '코드 품질'을 의미하지 않음. 코드 커버리지를 목표로 삼으면 개발자가 유지보수에 더 많은 시간이 드는 의미없는 테스트를 작성할 수 있음

## 불안정한 테스트 다루기

테스트 수준이 높을수록 실제 의존성을 더 많이 사용하게 됨. 이는 시스템이 제대로 작동한다는 신뢰성은 높이지만 동시에 불안정성이 증가함

고수준일수록 E2E 테스트에, 저수준일수록 단위 테스트에 가까움

![스크린샷 2025-03-24 오후 11 46 47](https://github.com/user-attachments/assets/7b3692b4-e04b-49db-a46b-b1b097b2d361)

## 불안정한 테스트를 발견했을 때 할 수 있는 일

불안정한 테스트는 장기적으로 팀, 조직, 회사에 큰 비용을 발생시킬 수 있음. 따라서 불안정한 테스트 없애는 것을 장기적인 목표로 삼고 방법을 알아가야 함

1. 문제 정의하기: '불안정'이 무엇을 의미하는지 명확히 정의하기, 예를 들어 프로덕션 코드를 변경하지 않고 TC 열번 실행한 후 결과가 일관되는지 테스트 해봄
2. 불안정하다고 판단되는 테스트는 임시 파이프라인으로 분리하여 따로 모아서 실행해보고, 하나씩 검토하면서 수정, 리팩터링, 삭제 과정 밟기

## 상위 수준의 테스트에서 안정성 유지하는 방법
- 테스트가 DB나 네트워크 서비스 같은 외부 시스템을 변경했으면 변경한 내용을 롤백
- 다른 테스트가 외부 시스템의 상태를 변경하지 않도록 하기
- 외부시스템과 의존성 제어하기 

> 테스트 코드 작성할때 신뢰성이 가장 중요하니까 염두하자 테스트 불안정성을 줄이려면 테스트 리팩토링하고, 불안정한 고수준 테스트를 덜 불안정한 저수준 테스트로 수정하거나, 불안정한 테스트를 삭제해라
