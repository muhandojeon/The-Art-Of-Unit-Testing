# 1장 단위 테스트의 기초

## 단위 테스트 정의

단위 테스트는 특정 **모듈이 의도된 대로 작동하는지 검증**하는 절차다.  
즉, 모든 **함수와 메서드**에 대한 테스트 케이스를 작성하는 절차를 말한다.

작업 단위(unit of work)에는 시작과 끝이 있으며, 이를 **진입점**과 **종료점**이라고 한다.  
함수는 내부에서 다른 함수나 모듈, 컴포넌트 따위를 사용할 수도 있다.  
= 진입점부터 종료점까지 아우르는 작업 단위는 단순한 함수 이상의 의미를 가진다.

> 책에서는 테스트 작성 대상이 `subject`, `system`, `SUT`(Suite Under Test)라고 하는데, 솔직히 와닿지 않았어요.  
> https://blog.100jiyeon.xyz/posts/goorm-commit-testing#테스트-대상  
> '기능을 테스트해야 하며 구현이 테스트에 드러나면 안 된다.'라는 문장을 공유해 봅니다 🙇‍♀

## 진입점과 종료점

> [!NOTE]
> 작업 단위에는 항상 **하나의 진입점**과 **하나 이상의 종료점**이 있다.  
> 작업 단위는 함수 하나만 의미할 수도 있고, 여러 함수를 의미할 수도 있다.

함수가 아니어도 모듈이나 컴포넌트도 작업 단위가 될 수 있다.  
작업 단위가 어떤 것이든 외부 환경에서 실행할 수 있는 진입점이 존재한다.  

> [!IMPORTANT]
> 의미 있는 작업 = 단순히 값을 반환하는 것, 어떤 상태를 변경하는 것, 서드 파티 코드(의존성)를 호출하는 것 = 뭔가 눈에 띄는 동작 = 종료점

종료점이 생긴다는 것은 추가적인 요구 사항이 생겼을 수도 있고, 결과에 영향을 미치는 무언가일 수도 있다.  

| 의존성 | 의존성이 아닌 것 |
| :-: | :-: |
| 파일에 무언가를 기록 | 어떤 행위를 쉽게 제어할 수 있는 경우 |
| 네트워크와 통신 | 메모리 내에서 실행되는 경우 |
| 다른 팀이 관리하는 코드 | 빠른 속도로 처리되는 경우 |
| 데이터베이스에 접근하는 행위 | |
| 오래 걸리는 계산 작업 | |

> [프론트엔드 테스트 코드와 의존성](https://jbee.io/articles/developments/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%BD%94%EB%93%9C%EC%99%80%20%EC%9D%98%EC%A1%B4%EC%84%B1)

## 종료점 유형

단위 테스트는 작업 단위를 호출하고, 그 작업 단위의 최종 결과로서 **하나의 특정 종료점을 테스트 검증 목표로 사용**한다.  
단위 테스트 범위는 진입점과 종료점 사이에 사용되는 함수와 모듈의 수에 따라 달라진다.

## 다른 종료점, 다른 기법

종료점 종류에 따라 테스트 방법이 달라진다.

- 반환 값이 있는 종료점 : 테스트하기 가장 쉬운 타입, 실행 결과 값을 받아 확인하면 끝
- 상태 값을 변경하는 종료점 : 조금 더 많은 작업 필요, 계속 호출하면서 의도대로 흘러갔는지 확인 필요
- 서드 파티를 호출하는 종료점 : 가장 많은 작업 필요, 외부에 실행 주도권이 있어서 코드 간섭이 힘들다, mock objects 활용

## 처음부터 테스트 코드 작성

검증 함수와 헬퍼 함수를 활용하는 게 좋다.  
Jest는 범용적인 헬퍼 함수를 많이 제공해 테스트를 작성하기 쉽다.  

## 좋은 단위 테스트의 특징

- 의도 이해하기 쉬움
- 자동화
- 같은 조건에서 항상 같은 결과
- 쉽고, 빠르게, 독립적으로, 메모리 내에서 실행
- 동기적 흐름으로 실행 (병렬 x)

## 통합 테스트

> [!NOTE]
> 통합 테스트는 단위 테스트에서 검증하지 못하는 시스템 전체의 상호 작용을 확인할 수 있는 중요한 역할을 한다.  
> 통합 테스트는 실제 의존성을 사용하고, 단위 테스트는 작업 단위를 의존성에서 격리해 항상 일관된 결과를 받는다.  
> 외부 자원을 사용하면 테스트 간에 의존성이 생길 수 있어서 순서대로 실행하지 않으면 결과가 올바르게 나오지 않을 수 있다.  

통합 테스트는 보통 단위 테스트보다 훨씬 느리며, 한 번에 너무 많이 테스트한다는 것이 문제다.  
실행 시간만 오래 걸리는 게 아니라 테스트를 준비하고 실행하는 데도 많은 시간이 걸린다. (= 데이터베이스 같은 내외부 의존성을 고려하기 때문)  
하나라도 실패하면 제대로 된 결과를 얻을 수 없다.  
여러 기능이 연쇄적으로 작용하기 때문에 버그 원인을 찾는 것도 쉽지 않다.  
큰 테스트에만 집중하다 보면 전반적으로 코드 신뢰도는 부족해지기 쉽다.  

## 테스트 주도 개발

1. 먼저 실패하는 테스트 작성
2. 테스트 통과하도록 코드 수정
3. 테스트 통과 확인
4. 리팩터링

> [!IMPORTANT]
> TDD의 가장 큰 장점은 테스트가 실패하는 것을 시작으로 기능 수정만으로 테스트를 통과하도록 한다는 것이다.
