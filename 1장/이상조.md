# 누구에게나 처음은 있다

테스트 코드는 팀의 공감대가 필요한 것 같다.  

# 단위 테스트 정의

작업 단위는 소프트웨어의 의미 있는 행동을 수행하는 최소 단위다.  
진입점이 유일하다.  
종료점은 의미있다.  
어떤 입력으로(진입) 어떤 결과를(종료) 내는지를 알 수 있으므로 문서의 역할  

# 진입점과 종료점

진입점을 읽고 나서, 어차피 다 함수 호출이 진입점이 되는 게 아닌가? 라고 생각했는데, 본문 sum 함수같은 예시보다 좀 더 복잡한 모듈을 테스트할 때는 그게 아닐 수 있겠다고 생각했다.  
결국 실행 후 외부에 어떤 결과가 나타났는지를 확인하는 것이 테스트라면 실행 컨텍스트를 종료하고 테스트 컨텍스트로 돌아가는 정확한 시점과 상황을 의미하는 종료점이 타당한 네이밍 같다.  
그러니까, 진입점을 통해 실행하고, 그 실행이 종료된 결과를 검증하는 것이라고 이해함.  

그리고 이건 1-2예제에서 totalSoFar()를 종료점으로 표현한 것에서 더 명확해졌음.  
사실 이 작업이 뭘 했냐? 라고 물으면(이게 행동에 가까운 것 같다.) 단순히 상태 값 변경이 종료점이 될텐데, 외부 컨텍스트에서 그 효과를 검증할 수 있는 형태로 결과를 제공하는 것이 종료점이라고 생각하면 컨텍스트로 이해하는 것이 조금 더 편해지는 것 같다~  

# 종료점 유형

반환 값이 기대와 동일한가?  
상태 값 변경이 기대와 동일한가?  
서드 파티 호출이 기대와 동일한가?  

# 다른 종료점, 다른 기법

반환 값이 기대와 동일한가? -> 반환 값을 비교한다.  
상태 값 변경이 기대와 동일한가? -> 간접 출력의 경우가 totalSoFar이 필요한 경우  
서드 파티 호출이 기대와 동일한가? -> 모의 객체

# 처음부터 테스트 코드 작성

테스트 프레임워크를 쓰자

# 좋은 단위 테스트의 특징

딸깍으로 가능한지가 좀 중요한 듯 하다. 확실히 허들을 계속 낮춰야하는 것 같음.  
변경 후에도 이전에 잘 동작하던 기능들이 여전히 정상적으로 작동하는지(회귀 테스트)  
'가능한 한 동기적인 흐름으로 실행되어야 한다'의 이유가 궁금한데, 이게 비결정적 실행이기 때문인 것 같다.  
예전에 회사에서 랜덤한 숫자를 활용한 테스트 코드를 작성한 경험이 있는데, 그때 비슷한 리뷰를 받았다.  
순차적이라는 보장이 없다면 때로는 성공하고, 때로는 실패하는 상황이 발생할 수 있다는 것(플래키한 상황이라고 표현)인데, 테스트의 독립성이나 격리 차원에서 좋지 않다.  

스텁에 대해서는 구체적으로 뭔지 설명을 안해줘서 좀 찾아봄.  
stub: 미리 정해진 데이터를 제공하는 구현체(e.g. API콜의 결과물을 실제 요청 대신 하드코딩된 객체로 반환하고 넘어가기)  
mock: stub의 역할을 포함하는데, 호출된 횟수나 인자같은 상호작용을 기록 및 검증할 수 있는 객체라고 함. (e.g. jest.fn()을 써서 만든 모킹 함수는 stub처럼 임의로 정해진 값을 반환할 수 있지만, 그게 호출되었는지, 몇 번 호출되었는지 등을 추가로 검증 가능)  
spy: 실 객체나 함수의 원래 동작을 그대로 수행하는데, 호출 내역만 기록하는 것 (e.g. const spy함수 = jest.spyOn(함수) 하면 함수가 몇 번 실행됐는지 알 수 있음.)  

그리고 이런 애들을 테스트 더블이라고 부른다고 함.  

# 통합 테스트

단위 테스트의 조건에 맞지 않으면 통합 테스트  
아래쪽으로 가면 좀 전통적인? 분류에 가까운 표현이 나옴. 여러 모듈이 함께 동작하여 결과를 만드는 방식을 테스트하는 것.  

# 최종 정리

단위 테스트는 진입점을 통해 작업 단위를 호출한 후 그 종료점을 확인하는 자동화된 코드다.  
단위 테스트는 거의 항상 단위 테스트 프레임워크를 사용하여 쉽게 작성할 수 있고 빠르게 실행할 수 있다.  
잘 작성된 단위 테스트는 신뢰성이 높고 가독성도 좋아서 유지 보수하기에 용이하다.  
우리가 운영하는 코드가 변경되지 않는 한 동일한 결과를 보장한다. 

# 테스트 주도 개발

근데... 사실 다들 테스트 주도 개발까진 아니더라도 머리속으로 계약 기반 설계 비스무리하게 하지 않나?  
결국 계약 기반 설계를 툴로 보완하면서 작업하는 느낌이라고 생각함.  
물론 TDD 안해봄;  

---

읽다 보니까 좋은 코드란 -> 테스트 코드를 작성하기 좋은 코드 -> SOLID 원칙을 준수하는 코드라는 생각이 듬.  
테스트하기 편하려면 독립적이어야 하고, 느슨하게 결합되어 있어야 하므로 좋은 아키텍처 설계에 가까워지는 것 같음.  
