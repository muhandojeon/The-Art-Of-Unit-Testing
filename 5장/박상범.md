# 5장 격리 프레임워크

3,4장에선 목과 스텁을 수동적으로 직접 작성하는 방법을 살펴봤고, 5장에선 우리가 흔히 아는 방식(격리 프레임워크라고 칭함)을 사용하여 목과 스텁을 동적으로 생성, 구성, 검증 해보자

## 격리 프레임워크 정의

격리 프레임워크
- 객체나 함수 형태의 목이나 스텁을 동적으로 생성, 구성, 검증 할 수 있게 해주는 API
- 목이라는 단어를 테스트에서 목과 스텁 모두를 가리키는 말로 사용할 때가 많아 용어를 달리해서 격리 프레임워크 라고 한다고 함
- 장점으로 반복적으로 코드 작성하는 일을 줄여주고, 테스트 지속성을 높일 수 있음
- 단점으로는 남용하게 되면 테스트를 읽을 수 없고, 신뢰할 수 없는 상황이 온다고 함

여기서 jest와 substitute.js 두가지를 사용하여 동적으로 가짜 모듈 만드는 법을 설명함
- jest는 순수 자바스크립트 친화적인 느슨한 타입
- substitute.js는 더 객체 지향적이고 타입스크립트 친화적이라고 함

## jest API에 대해 알아 둘 점
jest는 스텁을 만들 때나 목을 만들 때 거의 모든 곳에서 'mock'이라는 단어를 사용하기 때문에 헷갈릴 수 있음

그래서 'stub'이라는 단어를 mock과 동일한 의미로 사용하면 더 와닿을 것이라고 함

> 지금까지 이거때문에 엄청 헷갈렸었음;

## 직접 의존성의 추상화 고민

jest.mock API와 같은 기능의 단점은 제어권이 있는 코드까지 모두 가짜로 만들어 버린다는 점

API를 테스트에서 직접 사용하면 API가 변경될 때마다 수많은 테스트를 함께 변경해야 하기 때문에    
어댑터 파일을 만들어 함수에 대한 참조를 하나의 어댑터 파일에만 연결해서 추상화 하거나    
다른 방법을 통해 여러 코드에 문제가 생기는 상황을 피해야 한다고 함

> 앞에서도 계속 언급했었음, 고수준의 모듈에서 저수준의 모듈을 직접 참조하지마라(DIP)

## 함수형 스타일의 동적 목과 스텁

목 함수를 만들고 함수가 호출되었는지 확인하는 아래 코드를

```js
it('given logger and passing scenario', () => {
  let logged = '';
  const mockLog = { info: (text) => (logged = text) };
  ...

  expect(logged).toMatch(/PASSED/);
});
```

jest.fn() 함수로 쉽게 만들 수 있음

```js
it('given logger and passing scenario', () => {
  const mockLog = { info: jest.fn() };
  ...

  expect(mockLog.info).toHaveBeenCalledWith(expect.stringMatching(/PASS/));
});
```

이렇게 하면 별다른 노력 없이 특정 함수의 호출 추적하고 검증하기가 유용함

## 동적 스텁 설정

- mockReturnValue는 테스트 기간 동안 언제나 동일한 값을 반환하도록 설정이 됨
- mockReturnValueOnce는 함수가 실행되었을 때 최초 한번만 정해진 값을 반환함
  - 필자는 테스트 가독성과 유지보수 측면에서 mockReturnValue 선호한다고 함

> mockReturnValueOnce로 검증하면 좋을 예제가 있는지 궁금. 테스트를 여러개 작성해야되는게 아닌지 생각이 들었음

오류를 테스트해야 하거나 더 복잡한 작업을 해야 할 경우 mockImplementation()를 사용할 수도 있다고 함

> 예를 들어, `getProduct('a')`처럼 매개변수를 넘겨야 하는 api를 직접 호출해서 테스트해야할 때 사용할 수도 있는건가..?

```js
// e.g
import * as productAPI from "@/apis/product";

const getAssetMock = vi.spyOn(productAPI, 'getProduct').mockImplementation((type) => {
  if (type === "a") {
    return Promise.resolve(mocks.aProduct);
  }
  if (type === "b") {
    return Promise.resolve(mocks.bProduct);
  }
  return Promise.resolve([]);
});
```

## 격리 프레임워크의 장점과 함정

장점: 
- 손쉬운 가짜 모듈 생성
  - 코드가 서드파티 구현(jest)에 강하게 결합되어 있는건 단점이 될 수도 있음
- 값이나 오류를 만들어 내기가 더 쉬워짐

### 대부분의 경우 모의 객체가 필요하지 않다

격리 프레임 워크의 가장 위험하면서 무시하기 힘든 함정 => 무엇이든 쉽게 가짜로 만들 수 있는 것

모의 객체는 대부분의 단위테스트에서 기본적으로 사용해서는 안된다고 함

특수한 경우를 제외한 나머지 95% 이상은 모의 객체가 필요하지 않다고 한다

### 잘못된 대상 검증
테스트 입문하는 사람들이 흔하게 저지르는 실수는 실제로 의미 있는 동작을 검증하기보다는 단지 가능하기 때문에 검증을 한다는 것

> 명심하자

## 총평
- 지금까지 목과 스텁을 수동적으로 직접 작성하는 방법을 설명하다가 5장에서 우리가 흔히 아는 프레임워크를 사용하여 목과 스텁을 만드니 더 잘 이해할 수 있었다
- jest에서 stub에도 mock이라는 단어를 사용해서 내가 잘못알고 있었나 했는데, 책에서 jest는 mock이라는 단어를 통합해서 사용한다 해서 이전에 헷갈렸던 내용을 정리했다
- 목은 다른 방법으로는 테스트하기 어려울 떄만 사용해야된다고 강조한다. 그렇지 않으면 유지보수가 어려운 테스트가 된다고 하니 명심하려고 한다
