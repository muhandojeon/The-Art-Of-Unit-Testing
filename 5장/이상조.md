# 격리 프레임워크

목과 스텁을 수동으로 직접 작성한다면 가짜로 만들어야하는 인터페이스가 매우 복잡할 경우 문제가 된다. 반복 코드가 많아지는 것을 막으려고 추상화를 하고 또 그걸 추상화하고...  
이 문제를 우아하게 푸는 방식이 격리 프레임워크.  
런타임에 가짜 객체를 생성하고 설정할 수 있는 재사용 가능한 라이브러리를 말한다. 이러한 객체를 동적 스텁, 동적 목이라고 한다.  

격리 프레임워크라는 단어는 지은이가 붙인 이름. 원래는 모의 프레임워크라고 한다. 근데 목과 스텁을 구분해야한다는 본인의 철학에 맞지 않아 아예 격리 프레임워크로 부르기로 한 것 같음.  
작업 단위를 의존성에서 격리시킬 수 있기 때문에 격리 프레임워크라고 부른다.  

## 격리 프레임워크 정의

격리 프레임워크는 객체나 함수 형태의 목이나 스텁을 동적으로 생성, 구성, 검증할 수 있게 해주는 프로그래밍 가능한 API다. 격리 프레임워크를 사용하면 이러한 작업을 수작업으로 했을 때보다 더 간단하고 빠르며 코드도 더 짧게 작성할 수 있다.

근데 왜 테스트 지속성을 연 단위로 높여준다는 건지 모르겠다. 가짜로 만들고싶은 객체의 매개변수가 추가되는 상황 정도가 떠오르긴 함. 근데 그게 왜 연 단위지?


### 선택하기: 느슨한 타입 대 정적 타입

이건 좀 이해하기 어려운데, 애초에 우리는 대부분 코드를 타입스크립트로 짤건데.. 이런 구분이 왜 필요한지 잘 와닿지 않는다.  
마치 개발할 때 자바스크립트로 하는게 더 빠르고 편해~ 이런거랑 비슷하게 느껴지는데, 최근에 자바스크립트로 코드 짤때 진짜 고통받아서 공감하기가 어렵다.  

## 동적으로 가짜 모듈 만들기

명령: 반환값이 없음, 부수 효과가 있음
쿼리: 값을 반환함, 부수 효과가 없음

비밀번호 검증기가 구성 서비스에서 로그 레벨을 가져온다(로그 레벨이라는걸 반환받았으니 쿼리) 그리고 로깅 서비스에 로그를 남기라고 명령을 보낸다(값을 반환하지 않고 부수효과만 일으키니까 명령)

예시에서 jest.mock()으로 모듈을 모킹한다. 근데 걍 비밀번호 검증기에 prop 뚫어서 의존성 주입으로 해결하면 안되는 걸까? 책에서 말하는 이 방법이 더 자주 쓰이는 방법일까?  
애초에 prop 뚫어주는게 결합도도 낮추고 고수준 모듈이 저수준 모듈을 직접 참조하지 않는 방식으로 보인다.  
그냥 설명을 위한 예시라고 봐야 할까? 아니면 저렇게 짜는게 일반적인 걸까...??

### 제스트 API에 대해 알아 둘 점

jest.mock은 호이스팅으로 인해 가장 위쪽에 작성해야만 한다.

### 직접 의존성의 추상화 고민

흠.. 그러니까 어댑터를 두면 jest.mock의 단점을 보완할 수 있다?
예를 들어,

```
// 비밀번호검증기.js
import 윈스턴

const 비밀번호검증기 = () => { 윈스턴.log }
```
이런 코드라면, 테스트에서 이렇게 짜야 할 것임
```
jest.mock('윈스턴')
import 윈스턴
...
expect(윈스턴.log).toHaveBeenCalledWith("PASSED") 
```

근데 갑자기 윈스턴이 이제 log말고 logging이라고 메서드명을 바꾼다? 그럼 비밀번호 검증기도 바꿔야하고 테스트도 고쳐야함.

반면에 어댑터를 두면?

```
// 어댑터.js
import 윈스턴

const 로거 = {
  로깅하기: 윈스턴.log
}
```
```
jest.mock('./어댑터')
import 어댑터
...
expect(어댑터.로깅하기).toHaveBeenCalledWith("PASSED") 
```

테스트는 수정 안해도 됨

## 함수형 스타일의 동적 목과 스텁

스텁은 수작업 가능, 근데 목은 수작업 좀 번거롭다.
수작업으로 하려면 변수 하나 선언해서 걔가 어떻게 바뀌었는지를 확인해야했음. 근데 jest.fn을 쓰면 간편하게 해결가능하다. 제스트가 알아서 추적함

매처 종류
toBe(): 원시 값이나 객체 참조의 정확한 일치 검증  
toEqual(): 객체나 배열의 내용 비교 (깊은 비교)  
toStrictEqual(): 타입과 구조를 포함한 엄격한 비교  
요것들 차이 좀 헷갈렸음  

toBeGreaterThan(): 값이 특정 수보다 큰지 검증  
toBeLessThanOrEqual(): 값이 특정 수보다 작거나 같은지 검증  
이런것도 있음  

## 동적 스텁 설정

모듈과 함수 의존성의 반환 값을 조작하는 함수로 mockReturnValue, mockReturnValueOnce를 제공  
`const stubFunc = jest.fn().mockReturnValue("abc")`
`const stubFunc = jest.fn().mockReturnValueOnce("a").mockReturnValueOnce("b").mockReturnValueOnce("c")`

## 격리 프레임워크의 장점과 함정

- 손쉬운 가짜 모듈 생성
- 값이나 오류를 만들어 내기가 쉬워짐
- 가짜 객체 생성이 쉬워짐

### 대부분의 경우 모의 객체가 필요하지 않다

너무 편하게 만들 수 있게 되다 보니 테스트에는 모의 객체가 꼭 필요하다는 착각을 하게함

- 반환 값 (함수나 메서드가 돌려주는 결과)
- 상태 변화 (객체나 시스템의 내부 상태 변경)
- 서드 파티 의존성 호출 (외부 시스템이나 컴포넌트 호출) -> 얘만 모의 객체가 효과적이다

저자는 expect(mockFunction).toHaveBeenCalled()와 같은 검증보다는 실제 함수의 결과나 상태 변화를 직접 확인하는 expect(result).toBe(expectedValue)와 같은 방식을 우선적으로 고려하라는 말을 하고 싶은 것

### 잘못된 대상 검증
- 내부 함수가 다른 내부 함수를 호출했는지 검증 : 그니까 내부 구현말고... 외부에서 관찰할 수 있는 걸 검증해라는 말 같음. 블랙박스 테스트?
- 스텁이 호출되었는지 검증: 스텁은 필요한 데이터를 제공하는 역할만 하도록 하고, 그 결과로 인한 시스템의 동작을 검증해야 한다는 뜻
- 누군가가 시켜서 검증: 요구사항과 비즈니스 로직을 명확히 이해하고 필요한 것만 해라

### 테스트당 하나 이상 목을 사용

테스트에서는 하나의 관심사만 검증해라~

### 테스트의 과도한 명세화

스텁을 많이 쓰고 목은 쓰지마~  
스텁은 값 제공 용도로만 쓰고 호출여부는 신경쓰지마~

```ts
test('스텁을 목처럼 사용', () => {
  const stub = {
    함수: jest.fn().mockReturnValue({ 이름: '이상조' })
  };
  
  const result = 이름(stub);
  
  expect(stub.함수).toHaveBeenCalledWith(1); // 잘못된 방식
});

test('스텁을 스텁답게 ㄷㄷ', () => {
  const stub = {
    함수: jest.fn().mockReturnValue({ 이름: '이상조' })
  };
  
  const result = 이름(stub);
  
  expect(result.이름).toBe('이상조'); // 결과 검증
});
```



